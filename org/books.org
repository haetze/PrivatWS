#+TITLE: Books
#+SUBTITLE: Books I read
#+DATE: 01 Dec 2020
#+AUTHOR: Richard Stewing
#+EMAIL: richard.stewing@udo.edu
#+SETUPFILE: ../util/settings.org
#+INCLUDE: ../util/common.org
#+LANGUAGE: en

All list, especially /Boring/, are incomplete.

- Currently reading: /Competing with Unicorns: How the World's Best Companies Ship Software and Work Differently/


* Computer Stuff
- /The Pragmatic Programmer/ by David Thomas & Andrew Hunt
** Programming Languages
- /Parallel and Concurrent Programming in Haskell/ by Simon Marlow
- /Programming in GO/ by Mark Summerfield
- /Erlang Programming/ by Fransesco Cesarini & Simon Thompson
- /The Little Schemer/ by Daniel P. Friedman & Matthias Felleisen
- /The C Programming Language/ by Brian W. Kernighan & Dennis M. Ritchie
- /Programming Rust/ by Jim Blandy & Jason Orendorff
- /Building High Integrity Applications with Spark/ by John W. McCormick & Peter C. Chapin
- /Programming in Ada 2012/ by John Barnes
- /R for Data Science/ by Hadley Wickham & Garret Grolemund
- /Practical Common Lisp/ by Peter Seibel
- /The Rust Programming Language/ by Steve Klabnik, Carol Nichols, and Contributions from the Rust Community
- /Real World Haskell/ by Bryan O'Sullivan, John Goerzen, and Don Stewart
- /Type-Driven Development with Idris/ by Edwin Brady
** (Operating) Systems
- /Absolute FreeBSD/ by Michael W. Lucas
- /Understanding the Linux Kernel/ by Daniel P. Bovet & Marco Cesati
- /Distributed Systems - Principles and Paradigms/ by Andrew S. Tanenbaum & Maarten Van Steen
- /The Design and Implementation of the FreeBSD Operating System/ by Marshell Kirk McKusick, George V. Neville-Neil, and Robert N. M. Watson
** Tools
- /Managing Projects with GNU Make/ by Robert Mecklenburg
- /Practical Vim/ by Drew Neil
- /Pro Git/ by Scott Chacon & Ben Straub
- /The Org Mode 8 Reference Manual/ by Carsten Dominik and others
- /gnuplot in Action/ by Philipp K. Janert
- /Learning GNU Emacs/ by Debra Cameron, James Elliott, Marc Loy, Eric Raymond, and Bill Roseblatt
- /sed & awk: UNIX Power Tools (Nutshell Handbooks)/ by Arnold Robbins & Dale Dougherty
- /Black Hat Go/ by Tom Steele, Chris Patten, and Dan Kottmann
  - It's a fun read and a good introduction to Go in a pentesting context. 
    My only problem with it was, it never actually explains why Go is the best tool for the job. 
    I may have missed it but as it stands, it seems like a collection of tools implemented in Go.
    This doesn't have to be a bad thing, I assume it can be really useful as a starting block.
    It just isn't a general (as in /abstract/) introduction to the topic.
    There are a few errors in the text.
    For example, variable names in the Code don't match the ones in the text. 
    Can't find an example, so maybe I imaged it.
    Also the Code Listing could have used some more work:
    - Some Code is oddly formatted. (/eg./ Listing 13 - 5) 
      The comment that was added for the book is not indented correctly.
    - Some Code won't compile if copied from the book. (/eg./ Listing 14 - 2)
      Go won't compile code that uses '\' to extend the line. 
      At least not in the argument list to a function and probably not anywhere else either.
      Luckily the code on Github is correct.
      It is a little annoying because simple removing the '\' makes the code compile.
      It may not be /idiomatic/ Go but I really appreciate if code example compile if typed out =verbatim=.
    - The Listing scale horizontally in size with the code. (/eg./ Listing 11 - 5 compared to 5 - 6, picked at random)
      The same is true for the example shell commands. 
      It is not a huge deal, but it annoys me every time.
      Just pick one size and format the code to fit it.
      I wouldn't even care if you picked the biggest size and it didn't match the margins of the text.
      It wouldn't look that aesthetically pleasing but at least it's consistent.
      This way, it's the worst out from both worlds.
    Non of those are major issues, they just annoyed me.
- /Forge Your Future with Open Source/ by VM (Vicky) Brasseur
  - Good book. 
    Everything is explained in simple terms and is enjoyable to read.
    The complaint I have is that the answer to most questions is ''It depends.'' which even though true doesn't help a reader in that moment.
    ''It depends.'' is usually balanced with the place where the information can be looked up for a specific project. 
    So it is not a total loss.
    To be clear, this is not the authors fault, it's just the state of affairs in FOSS.
    I would say this is a great book to get an overview of how to work in FOSS or how to approach a FOSS project.
    My personal favorite sentence: ''You don't inherently deserve to be in the center of the onion, you must earn it.'' (p. 125)
** Mathematics
- /Category Theory For Programmers/ by Bartosz Milewski
- /The Little Typer/ by Daniel P. Friedman & David Thrane Chstiansen
- /Types and Programming Languages/ by Benjamin C. Pierce
- /Type Theory and Formal Proof/ by Rob Nederpelt & Herman Geuvers
- /The Art of Computer Programming - Volume 1/ by Donald E. Knuth
- /The Art of Computer Programming - Volume 2/ by Donald E. Knuth
- /Specifying System - The TLA+ Language and Tools for Hardware and Software Engineers/ by Leslie Lamport
  - This book describes the TLA+ Language(See below for a more detailed explanation) and a few tools that analyze it.
    It consists of four parts:
    1. Getting Started
    2. More Advanced Topics
    3. The Tools
    4. The TLA+ Language (Only skimmed)
    The First part introduces how to write basic specifications in TLA+.
    It introduces an intuitive semantic to explain most operators and should be sufficient for most people.
    The author and I agree in that respect. (See p. 3)
    
    The second part introduces advanced topics. 
    Among these are /Liveness/, /Fairness/, and /Real-time/  requirements, composition, and more advanced operators.
    I would have liked to see a more detailed description about composition. 
    The composition in chapter ten mostly highlights the composition on a logical level. 
    Using TLA+ on a larger scale requires are clear way to organize a large number of specification. 
    At the moment, the tools described in this book don't help with this and I would have appreciated advice beyond ''Put all your Modules in one directory''.
    (The book is not current in terms of tools, consider [[https://lamport.azurewebsites.net/tla/tla.html][The TLA+ Home Page]] for up-to-date information.)
    
    The third part introduces the [[https://en.wikipedia.org/wiki/Grammar_checker][syntax checker]], the [[https://en.wikipedia.org/wiki/Typesetting][typesetter]], and the model checker.
    The most interesting of those is the model checker (TLC).[fn::The other two do exactly what the name suggest.]
    TLC enumerates possible behaviors [fn::A sequence of states of a system] that satisfy the specification and checks that all invariants that the designer specified hold.
    TLC has some clear limits, for example, it can't find violations in infinite behaviors.
    (Technically behaviors are always infinite but that's not important here.)
    TLC's goal is to find errors in a specification by finding properties that don't hold.
    In general, it doesn't show freedom from errors because of aforementioned limits.
    In practice, it increases the confidence in the system modeled by the specification and can help to find the right system.

    The fourth book describes the TLA+ language and semantics in depth. 
    I didn't read that part because it's more like a reference.
    
    TLA+ (or /Temporal Logic of Actions/) describes systems in form of logical expressions.
    State transitions are described in an /action/ by relating the current state of a variable with the next state. 
    We can (in principle) describe any system this ways. 
    (This is true for Pnueli's temporal logic (see p. 2) and I think it still holds for TLA+.)
    It also allows reasoning about this systems.
    The problem I often have is that the implemented system and the TLA+ specification live in different worlds.
    Provided I have a specification of a system and a program that may implement this system, how do I verify if it's the case?
    The same problem arises when talking about hardware systems.
    This can't be done in general because it would solve Halting Problem.
    That doesn't mean it's worthless, it just means that verifying a specification and verifying a program are not both solved with TLA+.
    TLA+ can be used to describe the system in general and verify that it behaves as expected or wanted.
    It basically allows to check that you are building the right system before you start implementing it.
    This can be useful when TLA+ allows you to try things out more quickly than possible with a traditional implementation.
    It requires the user to use logic which can be hard to pick up for some.

    In conclusion, /Specifying System - The TLA+ Language and Tools for Hardware and Software Engineers/ by Leslie Lamport is a good book for anyone interested in system specification.
    The logic used for system specification is described thoroughly and intuitive interpretation of most operators are provided. 
    No prior knowledge about logic or system specification are required. 

* Thriller
- /Diener der Dunkelheit/ by Donato Carrisi
- /Der Nebelmann/ by Donato Carrisi

* Pop-Science
- /Die Mathematik des Daseins/ by Rudolf Taschner
- /Die Zahl die aus der K채lte kam/ by Rudolf Taschner
- /what if? Was w채re wenn?/ by Randall Munroe
* Boring (Since Dec 2020)
- /Woran Glauben - 10 Angebote f체r den aufgekl채rten Menschen/ by Rudolf Taschner
  - The title is very misleading. 
    It talks about these things not in contrast to theism, instead they are painted as things you could also believe.
    As such, I find it pointless because you can /believe/ in literally anything. 
    For example, the [[https://en.wikipedia.org/wiki/Flying_Spaghetti_Monster][Flying Spaghetti Monster]].
    I would have expected that the books explains how the these believes are consistent with what we know as /enlightened/ humans.
    When a flipped through the book and saw a chapter about God (I was about half-way through.), the last remaining pieces of hope for that went out of the window.
    I did give up in the chapter about the because I was very bored reading it. 
