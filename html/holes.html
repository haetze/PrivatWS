<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-03-28 Sun 16:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Idris' most important Feature</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Richard Stewing Richard Stewing" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../css/main.css">
<link rel="icon" type="image/png" href="/img/logo-full-size.png">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="https://stewing.dev"> HOME </a>
</div><div id="content">
<h1 class="title">Idris' most important Feature</h1>

<span class="open-button" id="open-button" onclick="openNav()">&#9776;</span>
<div class="sidenav" id="sidenav">
<a href="javascript:void(0)" class="close-button" onclick="closeNav()" id="close-button">&times;</a>
<a href="index.html" style position: fixed; top: 5px; left: 5px;>
<img src="../img/logo-full-size.png" alt="logo-full-size.png" width="150px" style="position: fixed; top: 5px; left: 5px;">
</a>

<p style="position: fixed; top: 180px; left: 5px;">
<a href="../html/index.html" style="position: fixed; top: 180px; left: 5px;">Home</a>
</p>

<p style="position: fixed; top: 210px; left: 5px;">
<a href="../html/CV-en-richard-stewing.html" style="position: fixed; top: 210px; left: 5px;">Curriculum Vitae</a>
</p>

<p style="position: fixed; top: 240px; left: 5px;">
<a href="../html/Keys.html" style="position: fixed; top: 240px; left: 5px;">Public Keys</a>
</p>

<p style="position: fixed; top: 270px; left: 5px;">
<a href="https://github.com/haetze/" style="position: fixed; top: 270px; left: 5px;">GitHub</a>
</p>

<p style="position: fixed; top: 300px; left: 5px;">
<a href="../html/books.html" style="position: fixed; top: 300px; left: 5px;">Books I read</a>
</p>

<p style="position: fixed; top: 330px; left: 5px;">
<a href="../html/SHA-256.html" style="position: fixed; top: 330px; left: 5px;">SHA 256 Calculator</a>
</p>

<p style="position: fixed; top: 360px; left: 5px;">
<a href="../html/Programming-Languages.html" style="position: fixed; top: 360px; left: 5px;">PLs &amp; Tools</a>
</p>

<p style="position: fixed; top: 390px; left: 5px;">
<a href="../html/blog.html" style="position: fixed; top: 390px; left: 5px;">Blog</a>
</p>

<p style="position: fixed; top: 420px; left: 5px;">
<a href="../html/feed.xml" style="position: fixed; top: 420px; left: 5px;">RSS Feed</a>
</p>

<p style="position: fixed; bottom: 20px; left: 5px;">
<a href="../html/archive.html" style="position: fixed; bottom: 20px; left: 5px;">Archive</a>
</p>

<p style="position: fixed; bottom: 5px; left: 5px;">
<a href="../html/impressum.html" style="position: fixed; bottom: 5px; left: 5px;">Impressum</a>
</p>

</div>



<script type="text/javascript">
function openNav() {
  document.getElementById("sidenav").style.width = "200px";
  document.body.style.paddingLeft = "210px";

  document.getElementById("close-button").style.pointerEvents = "all";
  document.getElementById("sidenav").style.pointerEvents = "all";

  document.getElementById("close-button").style.visibility = "visible";
  document.getElementById("sidenav").style.visibility = "visible";
  document.getElementById("open-button").style.visibility = "hidden";
}

function closeNav() {
  document.getElementById("sidenav").style.width = "0px";
  document.body.style.paddingLeft = "10px";

  document.getElementById("sidenav").style.pointerEvents = "none";
  document.getElementById("close-button").style.pointerEvents = "none";

  document.getElementById("close-button").style.visibility = "hidden";
  document.getElementById("sidenav").style.visibility = "hidden";
  document.getElementById("open-button").style.visibility = "visible";
}

document.body.onscroll = function(e) { 
  var x = window.matchMedia("(max-width: 450px)")
  if(0<e.currentTarget.scrollX && x.matches) { 
    closeNav();
  } 
}

</script>

<p>
Yesterday I saw this discussion on <a href="https://news.ycombinator.com/item?id=25978190">HN</a>. 
The author points out that ''static typing is pointless'' because the static type checker is just a crappy tool to encode simple invariants. (<a href="https://medium.com/better-programming/why-i-still-lisp-and-you-should-too-18a2ae36bd8">Link</a>)
More interesting invariants still need to be expressed in the documentation. 
I condensed his argument here. 
The essence is: Static Type Systems can't encode interesting invariants efficiently and make you jump through hoops for simple ones. 
So he rather not have these hoops and use dynamic types. <sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
I don't intend to spend a long time arguing against his points. 
The argument honestly bores me. 
I think he is wrong. 
He thinks he knows better than the computer which operations are acceptable and which are not. 
I'm happy that he trusts himself and others enough to work like that. 
I rather have a buddy who points out when I'm sloppy. 
Does that mean I have to do things his way? Yes. 
In return, I have some sense of guaranteed quality and can focus on other things. 
</p>

<p>
All this talking about Types made me think.
What makes them ergonomic? Why do I enjoy writing programs in Haskell more than writing them Rust? <sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
They are very similar in terms of their Type System.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> 
Yes, I like Haskell's syntax a lot more than Rust's. 
On the other hand, Rust gives me no garbage collection, which is pretty sweet. 
There is one thing I can't do in Rust (or at least don't know how) that is the greatest thing when I'm working on a program. 
Holes!
</p>

<p>
I first came across them in Idris, where you use them extensively.<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>
They are probably a lot older. 
Coq has probably had them for years. <sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>
There they are most commonly used for proof goals. 
Each goal (some statement to prove) corresponds to a term (the proof). 
If you have provided the term, then the hole is filled, and the goal disappears. 
If that doesn't make much sense like this, don't worry, we will talk about programming now. 
</p>

<p>
Unlike Coq, Idris is first and foremost a dependently typed programming language, not a proof assistant. 
Yes, you can prove stuff, but I would not call it the end goal. <sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>
When you are developing a program, the program is longer incomplete than complete. 
A whole allows you to tell the compile: 
''I'm not done. Please help me.''
Let's talk code.
Imagine we are writing the map function. 
And we know there are two cases (empty and non-empty lists), we don't know how to fill in the result. 
We could therefore write something like this:
</p>

<div class="org-src-container">
<pre class="src src-idris">my_map <span style="font-weight: bold; font-style: italic;">:</span> (a <span style="font-weight: bold; font-style: italic;">-&gt;</span> b) <span style="font-weight: bold; font-style: italic;">-&gt;</span> List a <span style="font-weight: bold; font-style: italic;">-&gt;</span> List b
my_map f [] <span style="font-weight: bold; font-style: italic;">=</span> ?hole_1
my_map f (x<span style="font-weight: bold; font-style: italic;">::</span>xs) <span style="font-weight: bold; font-style: italic;">=</span> ?hole_2
</pre>
</div>

<p>
We can now ask the compile for help. The compiler responds with two things:
</p>
<ol class="org-ol">
<li>The Type we need to construct. In this case, the return type of the function.</li>
<li>All bound variables and the corresponding types.</li>
</ol>

<div class="org-src-container">
<pre class="src src-verbatim">- + List.hole_1 [P]
 `--            b : Type       \
		a : Type        &gt; Context/Scope
		f : a -&gt; b     /
     ----------------------
      List.hole_1 : List b    &lt;- Type we need to construct

- + List.hole_2 [P]
 `--            b : Type
		a : Type
		f : a -&gt; b
		x : a
	       xs : List a
     ----------------------
      List.hole_2 : List b
</pre>
</div>

<p>
Maybe, I get overly excited, but this is useful. 
The big downside about type inference is, you can't see what Type a variable has by looking where it is declared. 
Holes fix this. 
I can now look at how to get to the Type I want. 
In the first case, we don't have a choice. 
(If we want the function to be total.)
</p>

<div class="org-src-container">
<pre class="src src-idris">my_map <span style="font-weight: bold; font-style: italic;">:</span> (a <span style="font-weight: bold; font-style: italic;">-&gt;</span> b) <span style="font-weight: bold; font-style: italic;">-&gt;</span> List a <span style="font-weight: bold; font-style: italic;">-&gt;</span> List b
my_map f [] <span style="font-weight: bold; font-style: italic;">=</span> []
my_map f (x<span style="font-weight: bold; font-style: italic;">::</span>xs) <span style="font-weight: bold; font-style: italic;">=</span> ?hole_2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-verbatim">- + List.hole_2 [P]
 `--            b : Type
		a : Type
		f : a -&gt; b
		x : a
	       xs : List a
     ----------------------
      List.hole_2 : List b
</pre>
</div>

<p>
So, we fill the whole and compile again. 
The compile checks what we have done and now only shows us the second hole. 
Now let's reason about what we want to do. 
We want to transform the list. 
It, therefore, stands to reason that we probably want to keep the structure of the list. 
Hence, we want the list constructor (that's the (::) operator) at the function's top level. 
So we probably want something like:
</p>

<div class="org-src-container">
<pre class="src src-idris">my_map <span style="font-weight: bold; font-style: italic;">:</span> (a <span style="font-weight: bold; font-style: italic;">-&gt;</span> b) <span style="font-weight: bold; font-style: italic;">-&gt;</span> List a <span style="font-weight: bold; font-style: italic;">-&gt;</span> List b
my_map f [] <span style="font-weight: bold; font-style: italic;">=</span> []
my_map f (x<span style="font-weight: bold; font-style: italic;">::</span>xs) <span style="font-weight: bold; font-style: italic;">=</span> ?hole_1 <span style="font-weight: bold; font-style: italic;">::</span> ?hole_2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-verbatim">- + List.hole_1 [P]
 `--            b : Type
		a : Type
		f : a -&gt; b
		x : a
	       xs : List a
     ----------------------
      List.hole_1 : b

- + List.hole_2 [P]
 `--            b : Type
		a : Type
		f : a -&gt; b
		x : a
	       xs : List a
     ----------------------
      List.hole_2 : List b

</pre>
</div>

<p>
We split the hole into two parts. 
For the first, we, again, don't have a choice. 
(This time for real.) 
In the context of the function, we only have one way to create the Type ''b''. 
That is by applying the function to the head of the list. 
Resulting in:
</p>

<div class="org-src-container">
<pre class="src src-idris">my_map <span style="font-weight: bold; font-style: italic;">:</span> (a <span style="font-weight: bold; font-style: italic;">-&gt;</span> b) <span style="font-weight: bold; font-style: italic;">-&gt;</span> List a <span style="font-weight: bold; font-style: italic;">-&gt;</span> List b
my_map f [] <span style="font-weight: bold; font-style: italic;">=</span> []
my_map f (x<span style="font-weight: bold; font-style: italic;">::</span>xs) <span style="font-weight: bold; font-style: italic;">=</span> f x <span style="font-weight: bold; font-style: italic;">::</span> ?hole_2
</pre>
</div>

<div class="org-src-container">
<pre class="src src-verbatim">- + List.hole_2 [P]
 `--            b : Type
		a : Type
		f : a -&gt; b
		x : a
	       xs : List a
     ----------------------
      List.hole_2 : List b
</pre>
</div>

<p>
With the same argument about the list's structure, we probably want to use the list's tail. 
So how can we transform it? 
We can use the function we are currently defining! 
And tada, we created the map function:
</p>

<div class="org-src-container">
<pre class="src src-idris">my_map <span style="font-weight: bold; font-style: italic;">:</span> (a <span style="font-weight: bold; font-style: italic;">-&gt;</span> b) <span style="font-weight: bold; font-style: italic;">-&gt;</span> List a <span style="font-weight: bold; font-style: italic;">-&gt;</span> List b
my_map f [] <span style="font-weight: bold; font-style: italic;">=</span> []
my_map f (x<span style="font-weight: bold; font-style: italic;">::</span>xs) <span style="font-weight: bold; font-style: italic;">=</span> f x <span style="font-weight: bold; font-style: italic;">::</span> my_map f xs
</pre>
</div>

<p>
This example probably seems rather pointless. 
</p>
<ol class="org-ol">
<li>The function is straightforward.</li>
<li>There are at most four variables.</li>
</ol>

<p>
I agree. 
But the same technique scales to more involved functions. 
Holes allow you to let the compiler tell you the local scope of the function you are defining. 
That means I don't need to keep track of what is in scope. 
The compiler does. 
Even more, when it shows me the types of things in scope. 
Of course, the more information resides in the Type, the more valuable this information becomes. 
With enough info provided, the compiler can even construct the correct term. <sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup> 
In this case, the compiler can't, and in fact, the problem is not generally solvable, but it can provide a good starting point.
</p>

<p>
This easy inspection of a function's environment is something I miss in Rust, mainly because the error message types seem to get unwieldy long very quickly. 
I would like to have something similar in Rust. <sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup>
I would also like to have a REPL if we are talking about things I want. 
But if I had to pick one, it would be Holes with the inspection capabilities shown above. 
I compared Rust and Haskell in the beginning and then went on to talk about Idris. 
Haskell also has holes. 
They are by far not as pretty as Idris'. 
They look like a terrible error message, but they provide the same functionality, and I use them regularly. 
Holes allow me to put something else into the compiler. 
The Type System keeps track of proper operations for me, so I don't have to think about that and holes keep track of variables in scope and their types for me. 
Now, I don't have to scan the code for variables and potentially miss one; I can ask the compiler to tell me what I have available. 
Dependent Types are fantastic and allow me to express more invariants, but they do have a cost. 
These invariants create proof obligations and they do have some cost. 
And not everyone is willing or able to pay this cost in a project. 
I do see broad applicability for holes, though. 
Maybe you are unsure about the argument to a function. 
Put a hole in its place, compile and first take a look at what you have available. 
For me, that seems like an extensive use case. 
Maybe I'm just not smart enough to keep all these things in my head at all times, and this solves a problem only I have, but I doubt that. 
</p>

<p>
In summary: Holes allow you to compile incomplete programs. 
The compiler helps you fill these holes by providing the context for each hole. 
This context consists of the local variables and their Types. 
Because the compiler keeps track of these variables, you don't have to scan the code and potentially miss one, hence lifting a programmer's burden. 
Additionally, even though they are beneficial when combined with an expressive Type System, their applicability seems not limited to those. 
(At least in theory.)
All this makes holes the most important feature Idris has. (In my opinion of course.)
</p>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">I'm not sure what I mean with interessting here either.
 He talkes about a sorted array as an example. 
I don't know if that's interesting, but let's go with kind of invariant.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">I enjoy writing Rust a lot. Cargo is so much nicer to use than Stack. (Yes, Stack does more but still)</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">I know there are differences, but it's close enough for me.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">See <i>Type Driven Development with Idris</i> by Edwin Brady.</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">Agda has them too. If you want to program with dependented Types, I would advice to use Agda. Maybe that changes when Idris 2.0 is released.</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">It is not very ergonomic. The Coq's tactics read a lot more like proofs humans would write.</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">For example, the <code>map</code> function for Vectors (Lists with the length encoded in the Type) can be constructed just from its Type.</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">With the LSP, the editor can show Types when you over a variable with the cursor, but that's to much movement for my taste.</p></div></div>


</div>
</div></div>
</body>
</html>
